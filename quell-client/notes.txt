/**
 * 
 * countries: []
 * country = {
 *  name: '',
 *  capital: '',
 *  
 * }
 * 
 * 
 * 1. Is there a list? To know: client.get(query-country)
 *    If nil --> break out, run full query
 *    If [country1, country2, ... ] --> we have a least some data that could be needed
 * 2. What fields do I need?
 *    [name, capital]
 * 3. Do I already have those fields?
 *    Name? Yes, so grab data or note data
 *    Capital? No --> added it to new query list
 * 4. Formulate new query, asking for fields not already in cache
 * 
 *     
 *  List of needed functions:
 *  1. Parse query into AST, maps query to cache-data representation
 *      --> query-country, country: {name, capital, cities}, city: {name, population}
 *   1A. Add any uniqueID fields not requested by the client
 *  2. unique key generator
 *      --> maps uniqueId config options, so that you know, e.g., that country is concated with id to form unique ID
 *  3. check if requested data is in the cache
 *     Is there a list of countries?
 *      For the first country:
 *        is there a name?
 *        is there a capital?
 *        is there a list of cities?
 *          --properties to check:  --> properties in cache: name , properties to fetch: population
 *          For the first city:
 *            is there a name? - yes
 *            is there a population - yes
 *          For the second city:
 *            is there a name? - yes
 *            is there a population - no
 *          For the third city:
 *            is there a name? - yes
 *            
 *          ...
 *          For the last city:
 *            is there a name? - yes
 *            
 *      For the second country?
 *      ...
 *      For the last country?
 *  4. Formulate truncated query -- asking for whatever was not fully present in cache
 *      country {
 *        cities {
 *          population
 *        }
 *      }
 *   5. Pass that truncated query to the graphql function, let it do its work
 *   6. Takes the truncated query's response and adds new data to the mold/skeleton
 *   7. Cache more filled-out objects
 *   8. Pass along the response
 * 
 * 
 *  cities {
 *    name
 *  }
 * 
 *  citiesByCountryId(country_id: 2) {
 *    name
 *    population
 *    language
 *  }
 * go look for the more general version of this query, and fire it off
 * 
 * 
 *  query-country-limit:5: [0: country-1, 1: country-2, ...]
 *  query-country-limit:10: [0: country-1, ..., 5: country-6, . . . ]
 *  query-cities
 *  country-1: {id, name, capital, cities}
 *  country-2: {id, name, capital, cities}
 *   ...
 *  city-1: {name, population, id, country_id}
 *  city-2
 * ---- JUSTIN'S IDEA ----
 *  countries: "{country-1: {"id": "1", "name": "Andorra"}, country-2: {"id": "2", "name":"Bolivia", capital:"Sucre"},...}"
 *  
 * 
 *  
 * IF ONE BIG STRING
 * countryData = client.get('allCountries');
 * parsed = JSON.parse(countryData)
 * for (let item in eachItemToCheck) {
 *   parse[item]
 * }
 * 
 * SEPARATE LITTLE STRINGS
 * for (let item in eachItemToCheck) {
 *  parse = JSON.parse(client.get('currentCountry'))
    parse[item];
 * }
 * 
 * 
 * 
 * countries(limit: 10) {
 *   name
 *   capital
 * }
 * 
 * countries(limit: 5) {
 *   name
 *   capital
 *   cities 
 * }
 */


 ===== ON CACHING =====



{
  country {
    name
    capital
    cities {
      name
      population
    }
  }
}

Cannot yield:
  country.name
  country.capital
  country.cities.name
  country.cities.population
Because country query returns an array, and it wouldn't be feasible to associate each country's name, capital, and cities. For example:
  country.name = [{name: "Andorra"}, {name: "Bolivia"}, {name: "Armenia"}]
  country.capital = [{capital: "Andorra la Vella"}, {capital: "Sucre"}, {capital: "Yerevan"}]
Will the results always be returned in the same order?

Instead, perhaps you want to store together all the fields associated with a TYPE:
  country: {
    query: {
      0: country1,
      1: country2,
      2: country3
    },
    country1: {name: "Andorra", capital: "Andorra la Vella"},
    country2: {name: "Bolivia", capital: "Sucre"},
    country3: {name: "Armenia", capital: "Yerevan"}
  }
This is better, but it still doesn't guarantee order. You still need an UNIQUE IDENTIFIER for each item in the collection:
    country-1: {id: 1, name: "Andorra", capital: "Andorra la Vella"},
    country-2: {id: 2, name: "Bolivia", capital: "Sucre"},
    country-3: {id: 3, name: "Armenia", capital: "Yerevan"}
    . . . 
    country-122: {id: 122, . . .}
You can either guess which field(s) contain unique identifiers -- you can, for example, look for id or _id -- or you can ask the user by requiring them to pass in an id field. What if the query does not contain a unique identifier? Maybe you have to add the unique identifer to each query.
So, for example, you might ask users to pass in a mapping of type to unique identifer:
{
  uniqueIds: {
    Country: id,
    City: _id,
    User: email,
    Post: (post) => post.author + post.date,
  },
  generalizedQueries: {
    citiesByCountryId: cities,
    
  }
}
Then if a query comes in that does not ask for __typename or the uniqueId, you'd add it.
